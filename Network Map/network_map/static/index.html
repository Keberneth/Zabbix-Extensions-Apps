<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nätverkskarta</title>
  <link href="bootstrap.min.css" rel="stylesheet">
  <script src="cytoscape.min.js"></script>
  <script src="cytoscape-cose-bilkent.js"></script>
  <style>
    body.dark-mode {
     background: #181a1b !important;
     color: #e8e6e3 !important;
   }
   #controls.dark-mode,
   #summary.dark-mode,
   #nbinfo.dark-mode {
     background: rgba(30, 30, 30, 0.95) !important;
     color: #e8e6e3 !important;
   }
   #cy.dark-mode {
     background: #23272e !important;
   }
   /* Add more selectors as needed for your UI */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 5px;
      z-index: 10;
      font-size: 14px;
      max-width: 350px;
      max-height: 95%;
      overflow: auto;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    #cy {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #f5f5f5;
      z-index: 1;
    }

    /* Sammanfattningsruta */
    #summary {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      font-size: 14px;
      max-width: 90%;
      max-height: 50%;
      overflow: auto;
      white-space: nowrap;
      font-family: monospace;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    #summaryHeader {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    #summaryHeader span {
      cursor: pointer;
      margin-right: 8px;
      color: #999;
      font-weight: bold;
    }
    #summaryFilters {
      margin-bottom: 5px;
    }
    #summaryFilters label {
      margin-right: 10px;
      font-size: 13px;
    }
    #summaryContent {
      white-space: pre;
      overflow: auto;
      max-height: calc(50vh - 80px);
    }

    /* NetBox-info */
    #nbinfo {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      font-size: 14px;
      max-width: 300px;
      max-height: 60%;
      overflow: auto;
      white-space: normal;
      font-family: monospace;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    #nbHeader {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    #nbHeader span {
      cursor: pointer;
      margin-right: 8px;
      color: #999;
      font-weight: bold;
    }
    #nbDetails {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #nbDetails li {
      margin-bottom: 4px;
    }
    #nbDetails li:hover {
      background: #f8f9fa;
      border-radius: 4px;
      padding: 2px;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="controls" class="shadow-sm">
    <h3>Nätverkskarta</h3>
    <label class="form-label">Välj server (tom → globalt filter):</label>
    <select id="hostSelect" class="form-select mb-2"><option value="">— Ingen, globalt filter —</option></select>
    <label class="form-label">Source: <input id="filterSrc" class="form-control form-control-sm" placeholder="node-id"></label>
    <label class="form-label">Dest: <input id="filterDst" class="form-control form-control-sm" placeholder="node-id"></label>
    <label class="form-label">Port: <input id="filterPort" class="form-control form-control-sm" placeholder="443 eller 1-5000"></label>
    <div class="form-check mb-2">
      <input class="form-check-input" type="checkbox" id="excludePub">
      <label class="form-check-label" for="excludePub">Exkludera publika IP</label>
    </div>
    <label class="form-label">IP/CIDR eller intervall att exkludera:
      <input id="filterIp" class="form-control form-control-sm" placeholder="192.168.1.10,10.0.0.0/16,192.168.1.0-192.168.1.68">
    </label>
    <label class="form-label">Min avstånd (px): <input id="minSep" class="form-control form-control-sm" placeholder="50"></label>
    <label class="form-label">Horisontell skala: <input id="scaleX" class="form-control form-control-sm" placeholder="1.0" value="1.0"></label>
    <label class="form-label">Vertikal skala: <input id="scaleY" class="form-control form-control-sm" placeholder="1.0" value="1.0"></label>
    <button id="btnApply" class="btn btn-primary btn-sm mt-2">Rita graf</button>
  <div style="display: inline-block; position: relative;">
    <button id="btnDownloadReport" class="btn btn-success btn-sm mt-2" ...>
      <span id="btnText">Ladda ner Rapport</span>
      <div id="progressBar" ...></div>
    </button>
    <button id="toggleDarkMode" class="btn btn-secondary btn-sm mt-2" style="margin-left: 8px;">Dark Mode</button>
  </div>
  </div>

  <div id="summary" class="shadow-sm" hidden>
    <div id="summaryHeader">
      <span id="minimizeSummary">[–]</span>
      <span id="closeSummary">[×]</span>
      <strong id="summaryTitle"></strong>
    </div>
    <div id="summaryFilters">
      <label class="form-label">Source: <input id="sumFilterSrc" class="form-control form-control-sm" placeholder="inkludera/exkludera..."></label>
      <label class="form-label">Dest: <input id="sumFilterDst" class="form-control form-control-sm" placeholder="inkludera/exkludera..."></label>
      <label class="form-label">Port: <input id="sumFilterPort" class="form-control form-control-sm" placeholder="inkludera/exkludera..."></label>
    </div>
    <div id="summaryContent"></div>
  </div>

  <div id="nbinfo" class="shadow-sm" hidden>
    <div id="nbHeader">
      <span id="minimizeNb">[–]</span>
      <span id="closeNb">[×]</span>
      <strong id="nbTitle"></strong>
    </div>
    <ul id="nbDetails"></ul>
  </div>

  <div id="cy"></div>

  <script>
    cytoscape.use(cytoscapeCoseBilkent);
    let rawData, cy;
    let summaryData = { incoming: [], outgoing: [] };

    const sel = document.getElementById('hostSelect');
    const summaryBox = document.getElementById('summary');
    const summaryTitle = document.getElementById('summaryTitle');
    const summaryContent = document.getElementById('summaryContent');
    const sumFsrc = document.getElementById('sumFilterSrc');
    const sumFdst = document.getElementById('sumFilterDst');
    const sumFport = document.getElementById('sumFilterPort');

    document.getElementById('closeSummary').onclick = () => { summaryBox.hidden = true; };
    document.getElementById('minimizeSummary').onclick = () => {
      const filters = document.getElementById('summaryFilters');
      const content = document.getElementById('summaryContent');
      if (filters.style.display === 'none') {
        filters.style.display = 'block';
        content.style.display = 'block';
        document.getElementById('minimizeSummary').textContent = '[–]';
      } else {
        filters.style.display = 'none';
        content.style.display = 'none';
        document.getElementById('minimizeSummary').textContent = '[+]';
      }
    };
    [sumFsrc, sumFdst, sumFport].forEach(i => i.addEventListener('input', updateSummaryDisplay));

    fetch('/api/network_map')
      .then(r => r.ok ? r.json() : Promise.reject('HTTP ' + r.status))
      .then(data => {
        data.edges = data.edges.filter(e => e.data.source && e.data.target);
        data.edges.forEach((e,i) => e.data.id = `${e.data.source}_${e.data.target}_${i}`);
        rawData = data;
        populateHostDropdown(data.nodes);
      });

    function populateHostDropdown(nodes) {
      sel.innerHTML = '<option value="">— Ingen, globalt filter —</option>';
      nodes.map(n => n.data.id).sort().forEach(id => {
        const o = document.createElement('option');
        o.value = o.textContent = id;
        sel.appendChild(o);
      });
    }

    function ipToLong(ip) {
      return ip.split('.').reduce((acc, octet) => ((acc<<8) + parseInt(octet,10))>>>0, 0);
    }
    function parseIpFilters(str) {
      if (!str) return [];
      return str.split(',').map(s=>s.trim()).filter(Boolean).map(s=>{
        const range = s.match(/^([\d.]+)\s*-\s*([\d.]+)$/);
        if (range) {
          let a = ipToLong(range[1]), b = ipToLong(range[2]); if (a>b)[a,b]=[b,a];
          return {type:'range',start:a,end:b};
        }
        const cidr = s.match(/^([\d.]+)\/(\d+)$/);
        if (cidr) {
          const mask = (~((1<<(32-+cidr[2]))-1))>>>0;
          const base = ipToLong(cidr[1]) & mask;
          return {type:'cidr',base,mask};
        }
        const v = ipToLong(s); if (!isNaN(v)) return {type:'exact',value:v};
      }).filter(Boolean);
    }
    function matchesIpFilter(ipStr, filters) {
      const num = ipToLong(ipStr);
      return filters.some(f =>
        (f.type==='exact'  && num===f.value) ||
        (f.type==='cidr'   && (num&f.mask)===f.base) ||
        (f.type==='range'  && num>=f.start && num<=f.end)
      );
    }

    function parsePortFilter(str) {
      if (!str) return null;
      const r = str.match(/^(\d+)\s*-\s*(\d+)$/);
      if (r) return {type:'range',min:+r[1],max:+r[2]};
      const v = parseInt(str,10);
      return isNaN(v)?null:{type:'exact',value:v};
    }

    function extractPort(label) {
      const m = label.match(/(\d+)/);
      return m ? +m[1] : NaN;
    }

    function partialMatch(val, filter) {
      return !filter || val.toLowerCase().includes(filter.toLowerCase());
    }

    function edgeMatches(d, srcF, dstF, portF, excl, ipF) {
      if (srcF && !partialMatch(d.source, srcF)) return false;
      if (dstF && !partialMatch(d.target, dstF)) return false;
      const port = extractPort(d.label);
      if (portF) {
        if (portF.type==='exact' && port!==portF.value) return false;
        if (portF.type==='range' && (isNaN(port) || port<portF.min || port>portF.max)) return false;
      }
      if (excl && d.isPublic) return false;
      if (ipF.length) {
        if (d.srcIp && matchesIpFilter(d.srcIp, ipF)) return false;
        if (d.dstIp && matchesIpFilter(d.dstIp, ipF)) return false;
      }
      return true;
    }

    function buildSubgraph(host, srcF, dstF, portF, excl, ipF) {
      const edges = rawData.edges.filter(e =>
        (e.data.source===host||e.data.target===host) && edgeMatches(e.data,srcF,dstF,portF,excl,ipF)
      );
      const ids = new Set([host]);
      edges.forEach(e=>{ ids.add(e.data.source); ids.add(e.data.target); });
      const nodes = Array.from(ids).map(id=>rawData.nodes.find(n=>n.data.id===id));
      return {nodes,edges};
    }

    function buildGlobalSubgraph(srcF, dstF, portF, excl, ipF) {
  const portTokens = parseSumTokens(document.getElementById('filterPort').value.trim());
  const edges = rawData.edges.filter(e => 
    edgeMatches(e.data, srcF, dstF, portF, excl, ipF) &&
    matchPortTokens(extractPort(e.data.label), portTokens)
  );
  const ids = new Set();
  edges.forEach(e => { ids.add(e.data.source); ids.add(e.data.target); });
  const nodes = Array.from(ids).map(id => rawData.nodes.find(n => n.data.id === id));
  return { nodes, edges };
}

    document.getElementById('btnApply').onclick = () => {
      const host = sel.value;
      const srcF = document.getElementById('filterSrc').value.trim();
      const dstF = document.getElementById('filterDst').value.trim();
      const portF = parsePortFilter(document.getElementById('filterPort').value.trim());
      const excl = document.getElementById('excludePub').checked;
      const ipF  = parseIpFilters(document.getElementById('filterIp').value.trim());
      const minSep = parseInt(document.getElementById('minSep').value.trim(),10)||50;
      const sx = parseFloat(document.getElementById('scaleX').value)||1;
      const sy = parseFloat(document.getElementById('scaleY').value)||1;
      const sub = host
        ? buildSubgraph(host,srcF,dstF,portF,excl,ipF)
        : buildGlobalSubgraph(srcF,dstF,portF,excl,ipF);
      drawGraph({ ...sub, minSep, sx, sy });
    };

    function drawGraph({nodes,edges,minSep,sx,sy}) {
      if (cy) cy.destroy();
      const degs = nodes.map(n=>n.data.degree);
      const minD = Math.min(...degs), maxD = Math.max(...degs);
      cy = cytoscape({
        container: document.getElementById('cy'),
        elements: {nodes, edges},
        layout: {
          name:'cose-bilkent', animate:false, fit:false,
          idealEdgeLength:minSep*1.5, nodeSeparation:minSep, avoidOverlap:true
        },
        style: [
          {
            selector:'node', style:{
              shape:'ellipse',
              width:`mapData(degree,${minD},${maxD},20,60)`,
              height:`mapData(degree,${minD},${maxD},20,60)`,
              label:'data(label)',
              'background-color':'data(color)','color':'#fff',
              'text-valign':'center','text-outline-width':2,'text-outline-color':'#333'
            }
          },
          {
            selector:'edge', style:{
              width:1,'line-color':'#999',
              'target-arrow-shape':'triangle','target-arrow-color':'#999',
              'curve-style':'bezier',label:'data(label)','font-size':8
            }
          },
          { selector:'.faded', style:{opacity:0.1} }
        ]
      });
      cy.ready(()=>{
        cy.nodes().forEach(n=>{
          const p = n.position();
          n.position({x:p.x*sx, y:p.y*sy});
        });
        cy.fit(50);
        window.addEventListener('resize',()=>{
          cy.resize(); cy.fit(50);
        });
      });

      cy.on('tap','node', e=>{
        showSummary(e.target);
        showNetboxInfo(e.target.data('id'));
      });
      cy.on('tap', e=>{
        if (e.target === cy) {
          cy.elements().removeClass('faded');
          document.getElementById('nbinfo').hidden = true;
        }
      });
    }

    // Parsta tokens i summary-filtret (inkludera/exkludera, intervall med '-')
    function parseSumTokens(str) {
      return str.split(',').map(s=>s.trim()).filter(Boolean).map(s=>{
        const exclude = s.startsWith('!');
        const token = exclude ? s.slice(1) : s;
        if (token.includes('-')) {
          const [a,b] = token.split('-').map(Number);
          return { range:[Math.min(a,b),Math.max(a,b)], exclude };
        } else {
          return { value: token, exclude };
        }
      });
    }

    // Matcha portnummer mot tokens med intervall + negation
    function matchPortTokens(portNum, tokens) {
      if (!tokens.length) return true;
      const includes = tokens.filter(t=>!t.exclude);
      const excludes = tokens.filter(t=>t.exclude);
      let ok = true;
      if (includes.length) {
        ok = includes.some(t =>
          t.range
            ? portNum >= t.range[0] && portNum <= t.range[1]
            : portNum === Number(t.value)
        );
      }
      if (!ok) return false;
      if (excludes.length && excludes.some(t =>
          t.range
            ? portNum >= t.range[0] && portNum <= t.range[1]
            : portNum === Number(t.value)
      )) {
        return false;
      }
      return true;
    }

    function matchTokens(text, tokens) {
      if (!tokens.length) return true;
      const inc = tokens.filter(t=>!t.exclude),
            exc = tokens.filter(t=>t.exclude);
      let ok = true;
      if (inc.length) ok = inc.some(t=>text.toLowerCase().includes(t.value.toLowerCase()));
      if (!ok) return false;
      if (exc.length && exc.some(t=>text.toLowerCase().includes(t.value.toLowerCase()))) return false;
      return true;
    }

    function updateSummaryDisplay() {
      const fs = parseSumTokens(sumFsrc.value);
      const fd = parseSumTokens(sumFdst.value);
      const fp = parseSumTokens(sumFport.value);
      const lines = [];

      if (summaryData.incoming.length) {
        lines.push('Inkommande:');
        summaryData.incoming.forEach(e=>{
          const pNum = extractPort(e.port);
          if (matchTokens(e.src,fs) && matchTokens(e.dst,fd) && matchPortTokens(pNum,fp)) {
            lines.push(`${e.src}\t${e.dst}\t${e.port}`);
          }
        });
      }

      if (summaryData.outgoing.length) {
        if (lines.length) lines.push('');
        lines.push('Utgående:');
        summaryData.outgoing.forEach(e=>{
          const pNum = extractPort(e.port);
          if (matchTokens(e.src,fs) && matchTokens(e.dst,fd) && matchPortTokens(pNum,fp)) {
            lines.push(`${e.src}\t${e.dst}\t${e.port}`);
          }
        });
      }

      summaryContent.textContent = lines.join('\n');
    }

    document.getElementById('closeNb').onclick = () => { document.getElementById('nbinfo').hidden = true; };
    document.getElementById('minimizeNb').onclick = function(){
      const c = document.getElementById('nbDetails');
      if (c.style.display==='none') { c.style.display='block'; this.textContent='[–]'; }
      else { c.style.display='none'; this.textContent='[+]'; }
    };

    function showSummary(node) {
      cy.elements().not(node.closedNeighborhood()).addClass('faded');
      const inc = rawData.edges.filter(edge => edge.data.target === node.id());
      const out = rawData.edges.filter(edge => edge.data.source === node.id());
      summaryData = {
        title: `Kommunikation för ${node.data('label')}`,
        incoming: inc.map(e=>({ src:e.data.source, dst:e.data.target, port:e.data.label })),
        outgoing: out.map(e=>({ src:e.data.source, dst:e.data.target, port:e.data.label }))
      };
      summaryTitle.textContent = summaryData.title;
      sumFsrc.value = sumFdst.value = sumFport.value = '';
      summaryBox.hidden = false;
      document.getElementById('summaryFilters').style.display = 'none';
      document.getElementById('summaryContent').style.display = 'none';
      document.getElementById('minimizeSummary').textContent = '[+]';
      updateSummaryDisplay();
    }

    function showNetboxInfo(hostname) {
      const nb = document.getElementById('nbinfo');
      nb.hidden = false;
      document.getElementById('nbTitle').textContent = `Info: ${hostname}`;
      document.getElementById('nbDetails').innerHTML = '<li>Hämtar data från NetBox…</li>';
      Promise.all([
        fetch(`/api/netbox/vm?name=${encodeURIComponent(hostname)}`),
        fetch(`/api/netbox/services-by-vm?name=${encodeURIComponent(hostname)}`)
      ])
      .then(([rVm,rSvcs])=>{
        if(!rVm.ok) throw 'VM saknas';
        return Promise.all([rVm.json(), rSvcs.json()]);
      })
      .then(([vm,svcs])=>{
        const cf=vm.custom_fields||{}, html=[];
        html.push(`<li>CPU: ${vm.vcpus} vCPU</li>`);
        html.push(`<li>RAM: ${(vm.memory/1024).toFixed(1)} GB</li>`);
        html.push(`<li>Disk: ${(vm.disk/1024).toFixed(1)} GB</li>`);
        html.push(`<li>Patch-fönster: ${cf.patch_window||'–'}</li>`);
        html.push(`<li>OS: ${cf.operating_system||'–'}</li>`);
        html.push(`<li>EOL: ${cf.operating_system_EOL||'–'}</li>`);
        html.push(`<li>Role: <strong>${vm.role?.display||'–'}</strong></li>`);
        if(Array.isArray(cf.ha_with_server)&&cf.ha_with_server.length){
          const links=cf.ha_with_server.map(h=>`<a href="${h.url}" target="_blank">${h.display}</a>`);
          html.push(`<li>HA: ${links.join(', ')}</li>`);
        }
        if(svcs.length){
          const lst=svcs.map(s=>`<li>${s.name} (${s.protocol.label}/${s.ports.join(',')})</li>`).join('');
          html.push(`<li>Tjänster:<ul>${lst}</ul></li>`);
        }
        html.push(`<li><a href="${vm.display_url}" target="_blank">Öppna i NetBox</a></li>`);
        document.getElementById('nbDetails').innerHTML=html.join('');
      })
      .catch(err=>{
        document.getElementById('nbDetails').innerHTML=`<li style="color:red">Fel: ${err}</li>`;
      });
    }

    document.getElementById('btnDownloadReport').onclick = function() {
      const btn = document.getElementById('btnDownloadReport');
      const progressBar = document.getElementById('progressBar');
      const btnText = document.getElementById('btnText');

      btn.disabled = true; // Disable the button
      btnText.textContent = 'Downloading...';

      let progress = 0;
      const interval = setInterval(() => {
        progress = (progress + 10) % 100; // Loop progress from 0 to 100
        progressBar.style.width = progress + '%';
      }, 200);

      fetch('/api/reports/download_zip')
        .then(response => {
          if (!response.ok) throw new Error('Network response was not ok');
          return response.blob();
        })
        .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.style.display = 'none';
          a.href = url;
          a.download = 'network_reports.zip';
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
        })
        .catch(err => {
          alert('Failed to download reports: ' + err);
        })
        .finally(() => {
          clearInterval(interval);
          progressBar.style.width = '100%'; // Complete the progress bar
          setTimeout(() => {
            progressBar.style.width = '0%'; // Reset the progress bar
            btn.disabled = false; // Re-enable the button
            btnText.textContent = 'Ladda ner Rapport';
          }, 500);
        });
    };
    </script>
  <script>
    // Göm fältet och etiketten
    document.querySelector('.form-label').style.display = 'none';
    document.getElementById('hostSelect').style.display = 'none';

    // Dark mode toggle
    document.getElementById('toggleDarkMode').onclick = function() {
      document.body.classList.toggle('dark-mode');
      document.getElementById('controls').classList.toggle('dark-mode');
      document.getElementById('summary').classList.toggle('dark-mode');
      document.getElementById('nbinfo').classList.toggle('dark-mode');
      document.getElementById('cy').classList.toggle('dark-mode');
    };
  </script>
</body>
</html>
